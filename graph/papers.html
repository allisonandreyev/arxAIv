<head>
  <style>
    body { margin: 0; font-family: "Times New Roman", Times, serif; }
  </style>

  <script src="//cdn.jsdelivr.net/npm/3d-force-graph"></script>
</head>

<body>
  <div id="3d-graph"></div>

  <script type="module">
    import * as THREE from "https://esm.sh/three"; 
    import SpriteText from "https://esm.sh/three-spritetext";

    const CLUSTER_COLORS = {
      1: "#7bb7ff",
      2: "#a5d9a5",
      3: "#f5eaba",
      4: "#c084c4",
      5: "#f5ba98"
    };
    const LABEL_FONT = '"Times New Roman", Times, serif';

    function makeGlowSphere(color, radius) {
      const glowRadius = radius * 1.8; 
      const geometry = new THREE.SphereGeometry(glowRadius, 24, 24);
      const material = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.25, 
          side: THREE.BackSide 
      });
      
      const glowMesh = new THREE.Mesh(geometry, material);
      
      glowMesh.renderOrder = -1; 
      return glowMesh;
    }  

    const Graph = new ForceGraph3D(document.getElementById('3d-graph'))
        .jsonUrl('papers.json')
        .nodeAutoColorBy('cluster')
        .nodeThreeObject(node => {
  
          const finalColor = CLUSTER_COLORS[node.cluster] || "#cccccc"; 
          const group = new THREE.Group();
          const radius = node.size ? node.size : 4;
          const sphere = new THREE.Mesh(
          new THREE.SphereGeometry(radius, 24, 24),
          new THREE.MeshStandardMaterial({
              color: finalColor, 
              roughness: 0.32,
              metalness: 0.25,
              emissive: finalColor, 
              emissiveIntensity: 0.18
          })
          );
          group.add(sphere);

          const glow = makeGlowSphere(finalColor, radius); 
          group.add(glow);

          const sprite = new SpriteText(node.name || "");
          sprite.material.depthWrite = false;
          sprite.fontFace = LABEL_FONT;
          sprite.fontWeight = "700";
          sprite.color = finalColor;
          sprite.textHeight = 8;
          sprite.center.y = -0.6;
          group.add(sprite);

          return group;})
        .nodeThreeObjectExtend(true)
        .onNodeClick(node => {
          const distance = 40;
          const distRatio = 1 + distance/Math.hypot(node.x, node.y, node.z);

          const newPos = node.x || node.y || node.z
            ? { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio }
            : { x: 0, y: 0, z: distance };

          orbitPauseUntil = performance.now() + 3200; 
          Graph.cameraPosition(
            newPos,
            node, 
            3000  
          );
        });
          
    Graph.d3VelocityDecay(.7); 
    Graph.d3AlphaDecay(0.0);  
    Graph.cooldownTime(15000);
      
    Graph.d3Force('charge').strength(-120);
    const ORBIT_DISTANCE = 700;
    const ORBIT_STEP = Math.PI / 480;
    let orbitAngle = 0;
    let orbitPauseUntil = 0;

    const orbitCamera = () => {
      const now = performance.now();
      if (now >= orbitPauseUntil) {
        const x = ORBIT_DISTANCE * Math.sin(orbitAngle);
        const z = ORBIT_DISTANCE * Math.cos(orbitAngle);
        Graph.cameraPosition({ x, y: ORBIT_DISTANCE * 0.05, z });
        orbitAngle += ORBIT_STEP;
      }
      requestAnimationFrame(orbitCamera);
    };

    // orbitCamera();

  </script>
</body>
