<head>
    <style> body { margin: 0; } </style>
  
    <script src="//cdn.jsdelivr.net/npm/3d-force-graph"></script>
  </head>
  
  <body>
    <div id="3d-graph"></div>
  
    <script type="module">
      import * as THREE from 'https://esm.sh/three';

      function makeGlowSprite(color, size) {
        const glowMaterial = new THREE.SpriteMaterial({
          color,
          transparent: true,
          opacity: 0.2,
          depthWrite: false
        });
        const glowSprite = new THREE.Sprite(glowMaterial);
        glowSprite.scale.set(size * 1.2, size * 1.2);
        return glowSprite;
      }

      const TYPE_COLORS = {
        generated: 0x66ccff,
        real: 0xff8c5a
      };

      function loadTextureWithFallback(primaryPath, fallbackPath) {
        const texture = new THREE.Texture();
        texture.colorSpace = THREE.SRGBColorSpace;

        const primaryImg = new Image();
        primaryImg.onload = () => {
          texture.image = primaryImg;
          texture.needsUpdate = true;
        };
        primaryImg.onerror = () => {
          if (!fallbackPath) return;
          const fallbackImg = new Image();
          fallbackImg.onload = () => {
            texture.image = fallbackImg;
            texture.needsUpdate = true;
          };
          fallbackImg.src = fallbackPath;
        };
        primaryImg.src = primaryPath;

        return texture;
      }

      const Graph = ForceGraph3D()(document.getElementById('3d-graph'))
        .nodeThreeObject(({ name, type }) => {
          const baseDir = type === 'real' ? 'real-figures' : 'figures';
          const safeName = name.includes('/') ? name.split('/').pop() : name;
          const file = name.startsWith(`${baseDir}/`) ? name : `${baseDir}/${safeName}`;
          const primaryPath = `../${file}`;
          const fallbackPath = baseDir === 'real-figures' ? `../figures/${safeName}` : null;

          const imgTexture = loadTextureWithFallback(primaryPath, fallbackPath);
          const material = new THREE.SpriteMaterial({ map: imgTexture, depthWrite: false });

          const group = new THREE.Group();
          const sprite = new THREE.Sprite(material);
          const size = 30;
          sprite.scale.set(size, size);
          group.add(sprite);
            
          const glowColor = TYPE_COLORS[type] || 0xffffff;
          const glow = makeGlowSprite(glowColor, size);
          group.add(glow);

          return group;
        })
        .nodeThreeObjectExtend(false)
        .nodeColor(node => TYPE_COLORS[node.type] || 0xffffff)
        .onNodeClick(node => {
          const distance = 40;
          const distRatio = 1 + distance/Math.hypot(node.x, node.y, node.z);

          const newPos = node.x || node.y || node.z
            ? { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio }
            : { x: 0, y: 0, z: distance };

          orbitPauseUntil = performance.now() + 3200;
          Graph.cameraPosition(
            newPos, 
            node, 
            3000  
          );
        });
      
      Graph.d3VelocityDecay(.8);
      Graph.d3AlphaDecay(0.0);   
      Graph.cooldownTime(15000); 
      Graph.d3Force('charge').strength(-120);

      const ORBIT_DISTANCE = 1200;
      const ORBIT_STEP = Math.PI / 480;
      let orbitAngle = 0;
      let orbitPauseUntil = 0;

      const orbitCamera = () => {
        const now = performance.now();
        if (now >= orbitPauseUntil) {
          const x = ORBIT_DISTANCE * Math.sin(orbitAngle);
          const z = ORBIT_DISTANCE * Math.cos(orbitAngle);
          Graph.cameraPosition({ x, y: ORBIT_DISTANCE * 0.05, z });
          orbitAngle += ORBIT_STEP;
        }
        requestAnimationFrame(orbitCamera);
      };
      
      fetch('both_figures.json')
        .then(res => res.json())
        .then(data => Graph.graphData(data));

      // orbitCamera();

    </script>
  </body>
